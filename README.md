
# Computer Science Concepts

Steve Yegge has an [interesting blogpost](http://steve-yegge.blogspot.in/2006/03/math-for-programmers.html) in which he says :
I think the best way to start learning math is to spend 15 to 30 minutes a day surfing in Wikipedia. It's filled with articles about thousands of little branches of mathematics. You start with pretty much any article that seems interesting (e.g. String theory, say, or the Fourier transform, or Tensors, anything that strikes your fancy.) Start reading. If there's something you don't understand, click the link and read about it. Do this recursively until you get bored or tired.
Doing this will give you amazing perspective on mathematics, after a few months. You'll start seeing patterns, ... and you'll download a PDF or buy a book, and you'll figure out enough to make you happy for a while.

So with this project i'm trying to apply that but mostly for computer science concepts that i don't know and math concepts related to it.

## Concepts
* [Idempotence](https://en.wikipedia.org/wiki/Idempotence)
* [Self-balancing binary search tree](https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree)
* [Referential transparency](https://en.wikipedia.org/wiki/Referential_transparency)
* [Lazy evaluation](https://en.wikipedia.org/wiki/Lazy_evaluation)
* [Locality of reference](https://en.wikipedia.org/wiki/Locality_of_reference)
* [Homoiconicity](https://en.wikipedia.org/wiki/Homoiconicity)
* [Macros](https://en.wikipedia.org/wiki/Macro_(computer_science))
* [Pattern matching](Https://en.wikipedia.org/wiki/Pattern_matching)
* [Communicating sequential processes](https://en.wikipedia.org/wiki/Communicating_sequential_processes)
* [Paramorphisms](http://stackoverflow.com/questions/13317242/what-are-paramorphisms)
* [Polymorphic recursion](https://en.wikipedia.org/wiki/Polymorphic_recursion)
* [Coinduction](http://lambda.jstolarek.com/2015/03/the-basics-of-coinduction/)
* [Hash consing](https://en.wikipedia.org/wiki/Hash_consing)
* [Locality of reference](https://en.wikipedia.org/wiki/Locality_of_reference)
* [Combinatory logic](https://en.wikipedia.org/wiki/Combinatory_logic)
* [Fixed-point combinator](https://en.wikipedia.org/wiki/Fixed-point_combinator)
* [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance)
* [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance)

## Techniques
* [Closure](https://en.wikipedia.org/wiki/Closure_(computer_programming))

## Algorithms Analysis
* [How To Avoid O-Abuse and Bribes](https://rjlipton.wordpress.com/2009/07/24/how-to-avoid-o-abuse-and-bribes/)
* [O(n log n)](http://www.crsr.net/Notes/BigO.html)
* [On fibonacci numbers as an example of asymptotic complexity](https://cdsmith.wordpress.com/2011/07/20/on-fibonacci-numbers-as-an-example-of-asymptotic-complexity/)
* [Proving Running Times With Induction](http://www.cs.cornell.edu/courses/cs312/2007fa/recitations/rec12.html)
* [Fast incremental sort](http://larshagencpp.github.io/blog/2016/04/23/fast-incremental-sort)
* [A beginner's guide to Big O notation](https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/)
* [What would cause an algorithm to have O(log log n) complexity?](http://stackoverflow.com/questions/16472012/what-would-cause-an-algorithm-to-have-olog-log-n-complexity)

## Algorithms
* [Binary search algorithm](https://en.wikipedia.org/wiki/Binary_search_algorithm)
* [QuickSelect Algorithm](https://en.wikipedia.org/wiki/Quickselect)
* [In-place algorithm](https://en.wikipedia.org/wiki/In-place_algorithm)
* [Radix Sort](https://en.wikipedia.org/wiki/Radix_sort)
* [Selection sort](https://en.wikipedia.org/wiki/Selection_sort)
* [Binary Search](https://www.topcoder.com/community/data-science/data-science-tutorials/binary-search/)
* [Rabin–Karp algorithm](https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm)
* [String searching algorithm](https://en.wikipedia.org/wiki/String_searching_algorithm)
* [Approximate string matching](https://en.wikipedia.org/wiki/Approximate_string_matching)
* [Knuth–Morris–Pratt algorithm](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)
* [Breadth-first search](https://en.wikipedia.org/wiki/Breadth-first_search)
* [In-place algorithm](https://en.wikipedia.org/wiki/In-place_algorithm)
* [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search)
* [Breath First Search](https://en.wikipedia.org/wiki/Breadth-first_search)
* [Cache-oblivious algorithm](https://en.wikipedia.org/wiki/Cache-oblivious_algorithm)

## Sorting
* [Counting sort](https://en.wikipedia.org/wiki/Counting_sort)
* [HeapSort](https://en.wikipedia.org/wiki/Heapsort)
* [Quicksort](https://en.wikipedia.org/wiki/Quicksort)
* [Merge Sort](https://en.wikipedia.org/wiki/Merge_sort)
* [Insertion Sort](https://en.wikipedia.org/wiki/Insertion_sort)
* [Tim Sort](https://en.wikipedia.org/wiki/Timsort)
* [Bucket Sort](https://en.wikipedia.org/wiki/Bucket_sort)
* [Why is quicksort better than other sorting algorithms in practice?](http://cs.stackexchange.com/questions/3/why-is-quicksort-better-than-other-sorting-algorithms-in-practice)
* [External Sorting](https://en.wikipedia.org/wiki/External_sorting)
* [What is a the fastest sorting algorithm for an array of integers?](http://cs.stackexchange.com/questions/18536/what-is-a-the-fastest-sorting-algorithm-for-an-array-of-integers)

## Tools
* [Package manager](https://en.wikipedia.org/wiki/Package_manager)

## Data structures
* [Tree data structure](https://en.wikipedia.org/wiki/Tree_(data_structure))
      - [Rosetta code Tree traversal](http://rosettacode.org/wiki/Tree_traversal)
* [Splay Tree](https://en.wikipedia.org/wiki/Splay_tree), An [implementation in  clojure](https://github.com/mathsaey/Clojure-Cache/blob/master/src/splay_tree.clj)
* [Treap](https://en.wikipedia.org/wiki/Treap)
      - An implementation in Go : https://github.com/steveyen/gtreap
      - [Key-value persistence library with Treap as the fundamental data structure](https://github.com/steveyen/gkvlite)
* [Retroactive data structures](https://en.wikipedia.org/wiki/Retroactive_data_structures)
* [Zipper](https://en.wikipedia.org/wiki/Zipper_(data_structure))
* [Linked list](https://en.wikipedia.org/wiki/Linked_list)
* [Binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree)
* [Double-ended queue](https://en.wikipedia.org/wiki/Double-ended_queue)
* [2-3 Tree](https://en.wikipedia.org/wiki/2%E2%80%933_tree)
* [Zipper](https://en.wikipedia.org/wiki/Zipper_(data_structure))
* [Priority queue](https://en.wikipedia.org/wiki/Priority_queue)
* [Pairing heap](https://en.wikipedia.org/wiki/Pairing_heap)
* [Binary tree](https://en.wikipedia.org/wiki/Binary_tree)
* [Trie](https://en.wikipedia.org/wiki/Trie)
* [Prefix trees; Comparison between Trie, Ternary Search Tree and Radix Tree](https://maitesin.github.io//Prefix_trees/)
* [A Probing Hash Table Framework](https://chara.cs.illinois.edu/sites/cgeigle/blog/2016/01/29/a-probing-hash-table-framework/)
* [AVL tree](https://en.wikipedia.org/wiki/AVL_tree)
* [Heap](https://en.wikipedia.org/wiki/Heap_(data_structure))
* [Hashtable](https://en.wikipedia.org/wiki/Hash_table)
* [Queue](https://en.wikipedia.org/wiki/Queue_(abstract_data_type))
* [Hashtable introduction](http://cecilsunkure.blogspot.fr/2012/07/hash-tables.html)
* [Five Myths about Hash Tables](https://hughewilliams.com/2012/10/01/five-myths-about-hash-tables/)

## Types
* [What the Heck are Algebraic Data Types ? ](http://merrigrove.blogspot.fr/2011/12/another-introduction-to-algebraic-data.html)
* [System F](https://en.wikipedia.org/wiki/System_F)
* [Typed lambda calculus](https://en.wikipedia.org/wiki/Typed_lambda_calculus)

## Operations
* [Car and Cdr](https://en.wikipedia.org/wiki/CAR_and_CDR)
* [Cons](https://en.wikipedia.org/wiki/Cons)

## Functional Programming
* [Monad (functional programming)](https://en.wikipedia.org/wiki/Monad_(functional_programming))

## Functions
* [Strict function](https://en.wikipedia.org/wiki/Strict_function)

## Lisp
* [cons](https://en.wikipedia.org/wiki/Cons)
* [Lisp reader](https://en.wikipedia.org/wiki/Lisp_reader)

## Programming Languages
* [miniKaren](https://en.wikipedia.org/wiki/MiniKanren)

## Mathematics 
* [Monotonic function](https://en.wikipedia.org/wiki/Monotonic_function)
* [Topology](https://en.wikipedia.org/wiki/Topology)
* [Topological space](https://en.wikipedia.org/wiki/Topological_space)
* [Homotopy](https://en.wikipedia.org/wiki/Homotopy)
* [Pythagorean triple](https://en.wikipedia.org/wiki/Pythagorean_triple)
* [Coprime integers](https://en.wikipedia.org/wiki/Coprime_integers)
* [Equivalence relation](https://en.wikipedia.org/wiki/Equivalence_relation)
* [Vacuous truth](https://en.wikipedia.org/wiki/Vacuous_truth)
* [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)
* [Möbius function](https://en.wikipedia.org/wiki/M%C3%B6bius_function)
* [Square free integer](https://en.wikipedia.org/wiki/Square-free_integer)
* [Inclusion–exclusion principle](https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle)

## Category Theory 
* [Morphism](https://en.wikipedia.org/wiki/Morphism)
* [Kan extension](https://en.wikipedia.org/wiki/Kan_extension)
* [Isomorphism](https://en.wikipedia.org/wiki/Isomorphism)
* [nlab: isomorphism](https://ncatlab.org/nlab/show/isomorphism)
* [Morphism](https://en.wikipedia.org/wiki/Morphism)
* [Bijection, injection and surjection](https://en.wikipedia.org/wiki/Bijection,_injection_and_surjection)

## NLP 
* [Text corpus](https://en.wikipedia.org/wiki/Text_corpus)
* [Part-of-speech tagging](https://en.wikipedia.org/wiki/Part-of-speech_tagging)
* [Part of speech](https://en.wikipedia.org/wiki/Part_of_speech)
* [Lemma](https://en.wikipedia.org/wiki/Lemma_(morphology))
* [Stem](https://en.wikipedia.org/wiki/Word_stem)
* [Stemming](https://en.wikipedia.org/wiki/Stemming)
* [Lemmatisation](https://en.wikipedia.org/wiki/Lemmatisationa)
* [Treebank](https://en.wikipedia.org/wiki/Treebank)

## Systems
* [Spell checker](https://en.wikipedia.org/wiki/Spell_checker)
* [1000x Faster Spelling Correction algorithm](http://blog.faroo.com/2012/06/07/improved-edit-distance-based-spelling-correction/)
